@namespace("org.ga4gh.models")
/**
This protocol defines common types used in the other GA4GH protocols. It does
not have any methods; it is merely a library of types.

Many of these types are related to defining sequence graphs. Sequence graph
concepts can be illustrated on a piece of double-stranded DNA with two nicks in
it, one on the top strand and one on the bottom strand. Here is an example where
the top strand is GGTGGNG.

```
        HO   -PO4
          | | <- top strand nick at position (2,+)
5’ -------   ------------------  3’
     G   G   T   G   G   N   G
     C   C   A   C   C   N   C
3’ ---------------   ----------  5’
position (3,-) -> | |  in bottom strand nick
              -PO4   OH

     0   1   2   3   4   5   6  <- coordinates
```

A sequence is a piece of double stranded DNA composed of a series of DNA
basepairs. In the default forward orientation a sequence is specified by the DNA
letters of its top strand, e.g. in this case GGTGGNG, where N indicates an
unknown base. The basepairs in this example sequence are indexed left to right
from 0 to 6 relative to this default orientation.  A sequence with Ns is called
a scaffold, one without Ns is called a contig. This one is a scaffold.

In its default forward orientation, each basepair has a left or "+" side and a
right or "-" side. For example, the left side of the T/A basepair in the above
example lies immediately to the left of this basepair. The left side of the T/A
basepair is represented by the position (2,+), where the index 2 is the same as
that of the basepair itself, and the "+" confirms that we mean the default
forward orientation. The right side is indicated using the "-" orientation. For
example, the right side of the following G/C base pair is represented by the
position (3,-).

One way to think about a position in a sequence is to imagine that the DNA
double helix is nicked, e.g. as shown in the top strand DNA nick above. When
double stranded DNA is nicked, the 5’-3’ phosphodiester bound between two
adjacent bases on one strand is broken, leaving an exposed hydroxyl group
(denoted HO or OH) on the 3’ side and an exposed phosphate group on the 5’
side (denoted -PO4). From a chemical point of view, you can think of a position
in a sequence as the the location in the double-stranded DNA of the exposed
phosphate group of a nick. The position (2,+) is shown as the –PO4 part of a
top strand nick in the diagram above, and the position (3,-) as the –PO4 part
of a bottom strand nick.

A nick is a prelude to double-stranded break. Each double-stranded break exposes
two free ends within a sequence, available to be ligated with other free ends.
The two nicks in the above example lead to two double-stranded breaks with free
ends (1,-) and (2,+) from the first break and (3,-) and (4,+) from the second
break as shown below.

```
          | |     | |
5’ -------   -----   ----------  3’
     G   G   T   G   G   N   G
     C   C   A   C   C   N   C
3’ -------   -----   ----------  5’
          | |     | |

     0   1   2   3   4   5   6  <- coordinates
```

This configuration decomposes the sequence into three segments. These three
segments have top strands GG, TG and GNG, respectively, in the example above.
Relative to the reference sequence GGTGGNG, in the default forward orientation,
the segment with top strand GG consists of a start position (0,+), a length 2,
an end position (1,-) and in this case, if we put the sequence GGTGGNG back
together by repairing these double stranded breaks, GG would have a join of its
end position to the start position (2,+) of next segment, the segment with top
strand TG. This is called the endJoin of the segment. Clearly it is unnecessary
to include both the length and the end position when defining a segment, so
normally only the length is specified.

Normally a segment will also have a join at its start position, called
startJoin. However, in the case of the segment with top strand GG there is no
join at the start position, i.e. startJoin is null. Note that if these two
double-stranded breaks were not repaired, both the startJoin and the endJoin
would be null for all three segments.

If the double-stranded breaks are repaired, restoring the original DNA
configuration, then this configuration is defined in terms of a sequence graph
that consists of the following set of three segments:

```
1. Segment with top strand GG in the reference sequence:
startJoin = null
start = (0,+)
length = 2
end = (1,-)
endJoin = (2,+)

2. Segment with top strand TG in the reference sequence:
startJoin = (1,-)
start = (2,+)
length = 2
end = (3,-)
endJoin = (4,+)

3.  Segment with top strand GNG in the reference sequence:
startJoin = (3,-)
start = (4,+)
length = 3
end = (6,-)
endJoin = null
```

If instead of a normal repair, the breaks were repaired such that the middle
segment is inverted, then the result would look like this

```
          | |     | |
5’ -------   -----   ----------  3’
     G   G   C   A   G   N   G
     C   C   G   T   C   N   C
3’ -------   -----   ----------  5’
          | |     | |
```

and the segments of the sequence graph would be specified as

```
1. Segment with top strand GG in the reference sequence:
startJoin = null
start = (0,+)
length = 2
end = (1,-)
endJoin = (3,-)

2. Segment with top strand TG in the reference sequence:
startJoin = (1,-)
start = (3,-)
length = 2
end = (2,+)
endJoin = (4,+)

3.  Segment with top strand GNG in the reference sequence:
startJoin = (2,+)
start = (4,+)
length = 3
end = (6,-)
endJoin = null
```

Notice that we always maintain the coordinate system on the reference sequence.
The inverted middle segment is specified as starting at a position corresponding
to a nick in the bottom strand of the reference sequence, and continuing on 2
basepairs in a right-to-left direction along the reference sequence. It does not
get new coordinates relative to its final position in the rearranged
conformation. This scheme allows us to employ a sequence graph to specify an
arbitrary DNA configuration joining segments of several different reference
sequences together at either of their ends.
*/
protocol Common {

/**
Indicates the DNA strand associate for some data item.
* `POS_STRAND`:  The postive (+) strand.
* `NEG_STRAND`: The negative (-) strand.
* `NO_STRAND`: Strand-independent data or data where the strand can not be determined.
*/
enum Strand {
  POS_STRAND,
  NEG_STRAND,
  NO_STRAND
}

/**
A `Position` is a side of a base pair in some already known sequence. A
`Position` is represented by a sequence name or ID, a base number on that
sequence (0-based), and a `Strand` to indicate the left or right side.

For example, given the sequence "GTGG", the `Position` on that sequence at
offset 1 in the forward orientation would be the left side of the T/A base pair.
The base at this `Position` is "T". Alternately, for offset 1 in the reverse
orientation, the `Position` would be the right side of the T/A base pair, and
the base at the `Position` is "A".

Offsets added to a `Position` are interpreted as reading along its strand;
adding to a reverse strand position actually subtracts from its `position`
member.
*/
record Position {
  /**
  The name of the reference sequence in whatever reference set is being used.
  Does not generally include a "chr" prefix, so for example "X" would be used
  for the X chromosome.

  If `sequenceId` is null, this must not be null.
  */
  union { null, string } referenceName = null;

  /**
  The UUID of the sequence on which the `Position` is located. This may be a
  `Reference` sequence, or a novel piece of sequence associated with a
  `VariantSet`.

  If `referenceName` is null, this must not be null.
  */
  union { null, string } sequenceId = null;

  /**
  The 0-based offset from the start of the forward strand for that sequence.
  Genomic positions are non-negative integers less than sequence length.
  */
  long position;

  /**
  Strand the position is associated with. `POS_STRAND` represents the forward
  strand, or equivalently the left side of a base, and `NEG_STRAND` represents
  the reverse strand, or equivalently the right side of a base.
  */
  Strand strand;
}

/**
A `Segment` represents a piece of sequence, which is optionally joined onto
other `Segment`s of sequence at each end, forming a graph. The bases for a
sequence are available through the `getSequence()` API call.

In the sequence "GTGG", the segment starting at index 1 on the forward strand
with length 2 is the "TG" on the forward strand. The length-2 segment starting
at index 1 on the reverse strand is "AC", corresponding to the first two base
pairs of the sequence, or the last two bases of the reverse complement.
*/
record Segment {
  /**
  The sequence ID and start index of this `Segment`. This base is always
  included in the segment, regardless of orientation.
  */
  Position start;

  /**
  The length of this `Segment`'s sequence. If `start` is on the forward strand,
  the `Segment` contains the range [`start.position`, `start.position` +
  `length`). If `start` is on the reverse strand, the `Segment` contains the
  range (`start.position` - `length`, `start.position`]. This is equivalent to
  starting from the side indicated by `start`, and traversing through that base
  out to the specified length.
  */
  long length;

  /**
  Start and end `Position`s where this `Segment` attaches to other sequences.
  Note that the segmentId for start and end might not be the same. The
  `Segment`s covering the sequences onto which this `Segment` is joined are
  called its "parents", while this segment is a "child".

  Joins may occur on the outer sides of the terminal bases in a sequence: the
  left side of the base at index 0, and the right side of the base with maximum
  index. These are the "terminal sides" of the sequence. `startJoin` is the join
  on the side indicated by `start`, and may only be set if that side is a
  terminal side. Similarly, `endJoin` is the join on the opposite side of the
  piece of sequence selected by the segment, and may only be set if that side is
  a terminal side. The value of `startJoin` or `endJoin`, if set, is the side to
  which the corresponding side of this `Sequence` is connected.
  */
  union { null, Position } startJoin, endJoin;
}

/**
A `Path` is an ordered list of `Segment`s. In general any contiguous path
through a sequence graph, with no novel adjacencies, can be represented by a
`Path`.
*/
record Path {
  /**
  We require that one of each consecutive pair of `Segment`s in a `Path` be
  joined onto the other.
  */
  array<Segment> segments = [];
}

/**
An enum for the different types of CIGAR alignment operations that exist.
Used wherever CIGAR alignments are used. The different enumerated values
have the following usage:

* `ALIGNMENT_MATCH`: An alignment match indicates that a sequence can be
  aligned to the reference without evidence of an INDEL. Unlike the
  `SEQUENCE_MATCH` and `SEQUENCE_MISMATCH` operators, the `ALIGNMENT_MATCH`
  operator does not indicate whether the reference and read sequences are an
  exact match. This operator is equivalent to SAM's `M`.
* `INSERT`: The insert operator indicates that the read contains evidence of
  bases being inserted into the reference. This operator is equivalent to
  SAM's `I`.
* `DELETE`: The delete operator indicates that the read contains evidence of
  bases being deleted from the reference. This operator is equivalent to
  SAM's `D`.
* `SKIP`: The skip operator indicates that this read skips a long segment of
  the reference, but the bases have not been deleted. This operator is
  commonly used when working with RNA-seq data, where reads may skip long
  segments of the reference between exons. This operator is equivalent to
  SAM's 'N'.
* `CLIP_SOFT`: The soft clip operator indicates that bases at the start/end
  of a read have not been considered during alignment. This may occur if the
  majority of a read maps, except for low quality bases at the start/end of
  a read. This operator is equivalent to SAM's 'S'. Bases that are soft clipped
  will still be stored in the read.
* `CLIP_HARD`: The hard clip operator indicates that bases at the start/end of
  a read have been omitted from this alignment. This may occur if this linear
  alignment is part of a chimeric alignment, or if the read has been trimmed
  (e.g., during error correction, or to trim poly-A tails for RNA-seq). This
  operator is equivalent to SAM's 'H'.
* `PAD`: The pad operator indicates that there is padding in an alignment.
  This operator is equivalent to SAM's 'P'.
* `SEQUENCE_MATCH`: This operator indicates that this portion of the aligned
  sequence exactly matches the reference (e.g., all bases are equal to the
  reference bases). This operator is equivalent to SAM's '='.
* `SEQUENCE_MISMATCH`: This operator indicates that this portion of the
  aligned sequence is an alignment match to the reference, but a sequence
  mismatch (e.g., the bases are not equal to the reference). This can
  indicate a SNP or a read error. This operator is equivalent to SAM's 'X'.
*/
enum CigarOperation {
  ALIGNMENT_MATCH,
  INSERT,
  DELETE,
  SKIP,
  CLIP_SOFT,
  CLIP_HARD,
  PAD,
  SEQUENCE_MATCH,
  SEQUENCE_MISMATCH
}

/**
A structure for an instance of a CIGAR operation.
*/
record CigarUnit {
  /** The operation type. */
  CigarOperation operation;

  /** The number of bases that the operation runs for. */
  long operationLength;

  /**
  `referenceSequence` is only used at mismatches (`SEQUENCE_MISMATCH`)
  and deletions (`DELETE`). Filling this field replaces the MD tag.
  If the relevant information is not available, leave this field as `null`.
  */
  union { null, string } referenceSequence = null;
}

}
