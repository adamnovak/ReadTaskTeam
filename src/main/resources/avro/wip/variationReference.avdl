@namespace("org.ga4gh.wip")

/**
A sequence graph is made progressively joining new sequence pieces, which we
call variants, into an existing graph.  This starts with a primary sequence. For
example consider the primary sequence in GRCh38 for a chromosome.  Then variants
can be joined into it, starting on a defined side of a defined base in the
existing structure, containing new sequence (potentially empty if a pure
deletion or breakpoint) and then joining back to another defined side of another
base in the current graph.

An arbitrarily complex reference graph is built this way, but we can also use
the same construction to specify individual variants from the reference.

Any base in the graph will have a unique identity defined by its variant id and
0-based position in the variant sequence.  It is oriented in the direction of
the variant sequence.

We support a context model for uniquely identifying bases in the graph.
Currently this is the UCSC left-right mapping proposal as proposed by Paten,
Haussler et al. - http://arxiv.org/abs/1404.5010
*/
protocol VariationReference {

import idl "../common.avdl";

/**
A `VariationReference` is a set of `Variant`s which typically comprise a
reference assembly, such as `GRCh38`. A `VariationReference` defines a common
graph coordinate space for comparing reference-aligned experimental data.
*/
record VariationReference {
  /** The variation reference ID. Unique in the repository. */
  string id;

  // `Variant` objects record their membership in the `VariationReference`,
  // sicne there will be a lot of them and we probably want to paginate them.

  /**
  Order-independent MD5 checksum which identifies this `VariationReference`. The
  checksum is computed by sorting all `md5checksum`s for all `Variant`s in the
  reference in ascending lexicographic order, concatenating, and taking the MD5
  of that value.
  */
  string md5checksum;

  /**
  ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g. 9606->human) indicating
  the species which this assembly is intended to model. Note that contained
  `Reference`s may specify a different `ncbiTaxonId`, as assemblies may
  contain reference sequences which do not belong to the modeled species, e.g.
  EBV in a human reference genome.
  */
  union { null, int } ncbiTaxonId = null;

  /** Optional free text description of this reference set. */
  union { null, string } description = null;

  // next information about the source of the sequences

  /** Public id of this reference set, such as `GRCh37`. */
  union { null, string } assemblyId = null;

  /** Specifies a FASTA format file/string. */
  union { null, string } sourceURI = null;

  /**
  All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
  with a version number, e.g. `NC_000001.11`.
  */
  array<string> sourceAccessions;

  /**
  A reference set may be derived from a source if it contains
  additional sequences, or some of the sequences within it are derived
  (see the definition of `isDerived` in `Reference`).
  */
  boolean isDerived = false;
}

/**
PLUS represents forwards, or the direction of increasing coordinates, while
MINUS represents reverse-complement, or the direction of decreasing coordinates.
*/
enum VariantSide {
  PLUS,
  MINUS
}


record VariantJoinLocation {
  string variantId; // id of the variant in which this location is based
  int position;     // 0-based
  VariantSide side;
  
  /**
  MD5 of the `md5checksum` of the variant being joined onto, the position as a
  decimal string, and "+" or "-" as appropriate for the side, in that order.
  Doesn't always have to be included, really just exists for making sure that
  the MD5 of a Variant and thus a VariationReference is well-defined.
  */
  union { null, string } md5checksum = null;
}

/**
Represents a chunk of sequence (possibly joined onto other such chunks) that is
part of a reference graph.
*/
record Variant {

  /** The variant ID. Unique within the repository. */
  string id;
  
  /**
  The ID of the `VariationReference` that this variant belongs to, if any.
  */
  union { null, string } variationReferenceId = null;
  
  /**
  The ID of the `VariantSet` that this variant belongs to, if it does not belong
  to a `VariationReference`.  
  */
  union { null, string } variantSetId = null;

  /** The length of this variant's sequence. */
  long length;

  /**
  MD5 of the upper-case sequence excluding all whitespace characters
  (this is equivalent to SQ:M5 in SAM).
  */
  string sequenceMd5checksum;

  /**
  MD5 of the sequenceMd5checksum, the MD5 of the startJoin, and the MD5 of the
  endJoin, in that order. Note that this means a variant may not join onto
  itself, or anything that joins onto it, or this hash would not be defined.
  */
  string md5checksum;

  /**
  All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
  with a version number, e.g. `GCF_000001405.26`.
  */
  array<string> sourceAccessions;

  /**
  Start and end locations of how this variant fits into the existing graph. May
  be null only for a primary sequence that is not joined onto any other. Note
  that the variantId for start and end may not be the same.
  */
  union { null, VariantJoinLocation } startJoin, endJoin;  
  
  /**
  The sequence to insert between startJoin and endJoin. We must be able to
  access sequence, but could allow it to be generated from a global identifier
  such as a versioned INSDC accession stored in info. [Propose adding additional
  object to define the latter in common.avdl]
  TODO: lazy download/pagination of sequence
  */
  string sequence; 

  // For variants that are part of a reference to which new sequences (e.g.
  // reads) are being mapped, a context function must be defined in
  // referenceVariationMethods.avdl so that bases in the reads can be mapped to
  // bases in the reference variant.

  /**
  We may need to say other things about the variant, e.g. origin, dbSNP...
  */
  map<string> info = {};
}

/*
Next we show how to provide information about samples.  The core idea is to
provide Calls which each contain information about an Allele in a CallSet.
Loosely the alleles correspond to rows in a VCF and the callsets to a column,
but there are some key differences.

First, we provide information separately about alleles not sites (unary variant
model).  We can determine from the graph whether two alleles are incompatible in
the same haplotype and hence "allelic" in the standard usage of the term.  Note
that this is a pairwise relation, not transitive, so we don't support sites as
sets of alleles in the way that VCF does.  This avoids the problems when merging
sites in VCF.  Our merge semantics are simple: only merge identical alleles.
Identity can be checked by name when sharing a global name and definition space,
or recursively by how the alleles are constructed from global objects when scope
is local.

Second, we represent phase information by separate haplotype callSets, rather
than using some sort of | or / or | notation or equivalent in the calls of a
genotype callSet.  So genotype callSets just contain allele counts (copy number)
or dosages.  This is the only way to provide phase data. Because we support
sparse callSets, which we hope can be lightweight, each piece of partial phasing
(as for example supported by phase sets in VCF) will be a separate haplotype
CallSet on the same sample.
*/

/**
This metadata represents VCF header information. Includes both the field value
and the information about the field definition, to allow a VCF header to be
reconstructed.
*/
record VariantSetMetadata {
  /** The top-level key. */
  string key;

  /** The value field for simple metadata. */
  string value;

  /**
  User-provided ID field, not enforced by this API.
  Two or more pieces of structured metadata with identical
  id and key fields are considered equivalent.
  */
  string id;

  /** The type of data. */
  string type;

  /**
  The number of values that can be included in a field described by this
  metadata.
  */
  string number;

  /** A textual description of this metadata. */
  string description;

  /** Remaining structured metadata key-value pairs. */
  map<array<string>> info = {};
}

/**
A `CallSet` has calls in a `VariantSet`. Some `Variant`s belong to
`VariantSet`s, while other belong to `VariationReference`s. A `VariantSet`
belongs to a `Dataset`. The variant set is equivalent to a VCF file.
*/
record VariantSet {
  /** The variant set ID. */
  string id;

  /** The ID of the dataset this variant set belongs to. */
  string datasetId;

  /**
  The `VariationReference` on which this `VariantSet` is defined.
  */
  string variationReferenceId;

  /** The date this variant set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this variant set was last updated in milliseconds from the
  epoch.
  */
  union { null, long } updated = null;

  // We don't list all the CallSets we have calls in because we expect there to
  // be many more CallSets than VariantSets.

  /**
  The metadata associated with this variant set. This is equivalent to
  the VCF header information not already presented in first class fields.
  */
  array<VariantSetMetadata> metadata = [];
}

/**
Some CallSets reflect genotype calls, while others reflect linked haplotype
calls.
*/
enum CallSetType {
  GENOTYPE,
  HAPLOTYPE
}

/**
A `CallSet` is a collection of variant calls for a particular sample. It belongs
to a `VariantSet`. A GENOTYPE-type CallSet is approximately equivalent to one
column in VCF.
*/
record CallSet {

  /** The call set ID. */
  string id;

  /** The call set name. */
  union { null, string } name = null;

  /** The sample this call set's data was generated from. */
  union { null, string } sampleId;

  /**
  A `CallSet` must be either a genotype or a haplotype. This field specifies
  which. A HAPLOTYPE-type `CallSet` is just a bag of `Call`s on the same piece
  of DNA; there may be more than one way to traverse the graph as a single
  haplotype.
  */
  CallSetType callsetType;
  
  // For diploid genotypes the copy number of a Variant in a Call will typically
  // be 0, 1 or 2; for haplotypes it will be 0 or 1

  /**
  The IDs of the variant sets this call set has calls in. These must all belong
  to the same Dataset; a CallSet cannot span Datasets.
  */
  array<string> variantSetIds = [];

  /** The date this call set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this call set was last updated in milliseconds from the
  epoch.
  */
  union { null, long } updated = null;

  /**
  A map of additional call set information.
  */
  map<array<string>> info = {};
}

/**
Represents an occurrence of a `Call` on a single linear molecule of DNA,
positioned and oriented relative to other occurrences of `Call`s on that same
piece of DNA. The same call may appear multiple times in the same traversal.

Neested inside the `Call`, since otherwise we would have to give IDs to every
`Call`.
*/
record TraversalMembership {
  /**
  ID of the traversal we are asserting occurrence on. The traversal doesn't 
  exist as a retrievable Traversal object, the ID just unifies all of the
  occurrences into a single conceptual traversal.
  */
  string traversalId;
  
  /**
  Where along the traversal does this occurrence of this `Call` happen?
  */
  long position;
  
  /**
  What orientation is the `Variant` represented by this `Call` occurring in at
  that position in the traversal?
  */
  VariantSide orientation;
}

/**
A Call is an instance of a Vartiant in a CallSet.
*/
record Call {
  /**
  References the ID of the `CallSet` that this Call belongs to.
  */
  string callSetId;
  
  /**
  References the ID of the `Variant` that this Call reflects the presence of.
  May be in the applicable `VariationReference` or in the `VariantSet` instead.
  */ 
  string variantId;

  /**
  HAPLOTYPE-type CallSets double as phase sets, so we don't need phase sets. We
  do however need these traversals in case we need to disambiguate phasing
  through some sort of complicated duplication on a single haplotype.
  
  Having n of these is an assertion that this `Call` has copy number at least n.
  The copy number data that occurs later may not contradict that by e.g. listing
  a nonzero probability for a copy number less than n.
  
  Only `Calls` in the same `CallSet` may be part of the same traversal.
  
  TODO: Is there a way to do this while allowing some things in the traversal to
  maybe not exist?
  */
  array<TraversalMembership> traversalMemberships;
  
  // We have various ways of specifying what the call actually is.
  // Not all of the following will be present, but at least one should be
  
  /**
  0 for not present in callSet, 1 for single copy, 2 for 2 copies etc. 
  */
  union { null, int } copyNumber = null; 
  
  /**
  Expected value of copyNumber.
  */
  union { null, float } dosage = null;
  
  /**
  Probability that copy number is k: 0..n
  */ 
  array<float> probability = [];
  
  /**
  Likelihood of data given copy number k.
  */
  array<float> likelihood = []; 
  
  /**
  Number of reads supporting this allele (DP in VCF).
  */
  union { null, int } readCount = null;
  
  /**
  Potential other evidence for the call.
  */
  map<string> evidence = {};
}


// Took away the Segments/Alleles method of specifying the presence of arbitrary
// substrings which may or may not overlap with variants. Do we want to have
// that capability? Or do we want to force people to make assertions about
// whether what they called was the same as or distinct from known sequence?

// VariantScaffolds are now replaced by memberships of calls in traversals.

} // end of protocol
